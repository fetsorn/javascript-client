const SchemaToTypescript = require("json-schema-to-typescript");
const fs = require("fs");
const path = require("path");

async function generateManifestTypes() {
  // Fetch all schemas within the @web3api/manifest-schemas/formats directory
  const formatsDir = path.join(
    path.dirname(require.resolve("@web3api/manifest-schemas")),
    "formats"
  );

  // Get all format types (web3api, web3api.build, etc)
  const formatTypes = fs.readdirSync(
    formatsDir, { withFileTypes: true }
  ).filter((dirent) => dirent.isDirectory);

  // For each format type
  for (let i = 0; i < formatTypes.length; ++i) {
    const formatTypeName = formatTypes[i].name;
    const formatTypeDir = path.join(formatsDir, formatTypeName);
    const formatModules = [];

    // Get all JSON schemas for this format type (v1, v2, etc)
    const formatSchemas = fs.readdirSync(formatTypeDir);

    for (let k = 0; k < formatSchemas.length; ++k) {
      const formatSchemaName = formatSchemas[k];
      const formatVersion = formatSchemaName.replace(".json", "");
      const formatSchemaPath = path.join(formatTypeDir, formatSchemaName);

      try {
        // Parse the JSON schema
        const formatSchema = JSON.parse(
          fs.readFileSync(formatSchemaPath, { encoding: "utf-8" })
        );

        // Convert it to a TypeScript interface
        const tsFile = await SchemaToTypescript.compile(
          formatSchema,
          formatSchema.id
        );

        // Emit the result
        const tsOutputPath = path.join(__dirname, `/../src/manifest/formats/${formatTypeName}/${formatVersion}.ts`);
        fs.mkdirSync(path.dirname(tsOutputPath), { recursive: true });
        fs.writeFileSync(
          tsOutputPath,
          `/* eslint-disable @typescript-eslint/naming-convention */\n${tsFile}`
        );

        // Add metadata for the root index.ts file to use
        formatModules.push({
          interface: formatSchema.id,
          version: formatVersion
        });
      } catch (error) {
        console.error(`Error generating the Manifest file ${formatSchemaPath}: `, error);
        throw error;
      }
    }

    // Lastly, create an index.ts file that exports root types that aggregate all versions
    let tsSrc = `/* eslint-disable @typescript-eslint/naming-convention */
/* tslint:disable */
/**
 * This file was automatically generated by generateManifestTypes.
 * DO NOT MODIFY IT BY HAND. Instead, modify generateManifestTypes,
 * and run node ./scripts/generateManifestTypes.js to regenerate this file.
 */
`;

    const lastItem = (arr) => arr[arr.length - 1];

    const formatInterfaces = [];
    const formatType = lastItem(formatModules).interface;

    // Import version interfaces
    tsSrc += formatModules.map((format) => {
      const tsCompatVersion = format.version.replace(/\./g, "_").replace(/\-/g, "_");
      formatInterfaces.push(`${formatType}${tsCompatVersion}`);
      return `\nimport {\n  ${format.interface} as ${formatType}${tsCompatVersion}\n} from "./${format.version}";`;
    }).join("\n") + "\n";

    // Export renamed version interfaces
    tsSrc += `\nexport {\n  ${formatInterfaces.join(",\n  ")}\n}\n`;

    // Export an enum of all version strings
    tsSrc += `\nexport enum ${formatType}Formats {\n${formatModules.map((format) => {
      return `  "${format.version}" = "${format.version}",\n`
    }).join("")}}\n`;

    // Export an "any type" of all version interfaces
    tsSrc += `\nexport type Any${formatType} =${formatInterfaces.map((formatInterface) => {
      return `\n  | ${formatInterface}`;
    }).join("")};\n`;

    // Export the latest interface, and version string
    tsSrc += `\nexport type ${formatType} = ${lastItem(formatInterfaces)};\n`
    tsSrc += `\nexport const latest${formatType}Format = ${formatType}Formats["${lastItem(formatModules).version}"]\n`;

    // Emit the result
    const tsOutputPath = path.join(__dirname, `/../src/manifest/formats/${formatTypeName}/index.ts`);
    fs.mkdirSync(path.dirname(tsOutputPath), { recursive: true });
    fs.writeFileSync(tsOutputPath, tsSrc);
  }

  return Promise.resolve();
};

generateManifestTypes()
  .then(text => {
    process.exit();
  })
  .catch(err => {
    console.error(err);
    process.abort();
  });
