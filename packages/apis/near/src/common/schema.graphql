# Supported public key types
enum KeyType {
  ED25519
}

# Account public key data
# TODO: This throws an exception when using PublicKey in the Transaction type.
# Hacky fixes include making the type a Uint and having the PublicKey type implement Signature as an interface.
#type PublicKey {
#  keyType: KeyType!
#  data: Bytes!
#}
type PublicKey implements Signature {}

type Signature {
  keyType: KeyType!
  data: Bytes!
}

# Access key permissions determine how an account is allow to interact with a contract
type AccessKeyPermission {
  _: String
}

# Full access permission allows an account to call all public contract functions
type FullAccessPermission implements AccessKeyPermission {}

# Function call permissions describe which contract functions an account can call
type FunctionCallPermission implements AccessKeyPermission {
  receiverId: String!
  methodNames: [String!]!
  allowance: BigInt
}

# Access keys contain access key permissions, which determine how an account is allowed to interact with a contract
type AccessKey {
  nonce: BigInt!
  permission: AccessKeyPermission!
}

# Action types define the data necessary to complete a type of action in a transaction
type Action {
  _: String
}

# holds content necessary to create an account
type CreateAccount implements Action {}
# holds content necessary to send a transaction that deploys a contract
type DeployContract implements Action { code: Bytes! }
# holds content necessary to send a transaction that calls a contract function
type FunctionCall implements Action { methodName: String! args: Bytes! gas: BigInt! deposit: BigInt! }
# holds content necessary to send a transaction that transfers NEAR?
type Transfer implements Action { deposit: BigInt! }
# holds content necessary to send a transaction that stakes NEAR
type Stake implements Action { stake: BigInt! publicKey: PublicKey! }
# holds content necessary to send a transaction that adds an access key
type AddKey implements Action { publicKey: PublicKey! accessKey: AccessKey! }
# holds content necessary to send a transaction that deletes an access key
type DeleteKey implements Action { publicKey: PublicKey! }
# holds content necessary to send a transaction that creates a NEAR account
type DeleteAccount implements Action { beneficiaryId: String! }

type Transaction {
  signerId: String!
  publicKey: PublicKey!
  nonce: BigInt
  receiverId: String!
  blockHash:  Bytes!
  actions: [Action!]!
}

type SignedTransaction {
  transaction: Transaction!
  signature: Signature!
}

# Return value of Mutation.signTransaction(...); contains transaction hash and signed transaction
type SignTransactionResult {
  hash: Bytes!
  signedTx: SignedTransaction!
}


type ExecutionError {
  error_message: String!
  error_type: String!
}

type FinalExecutionStatus {
  successValue: String
  failure: ExecutionError
}

type ExecutionStatus {
  successValue: String
  successReceiptId: String
  failure: ExecutionError
}

# Execution status of a sent transaction
type ExecutionOutcome {
  logs: [String!]!
  receipt_ids: [String!]!
  gas_burnt: BigInt!
  status: ExecutionStatus!
}

type ExecutionOutcomeWithId {
  id: String!
  outcome: ExecutionOutcome!
}

# Final outcome of a sent transaction
type FinalExecutionOutcome {
  status: FinalExecutionStatus!
  transaction: Transaction!
  transaction_outcome: ExecutionOutcomeWithId!
  receipts_outcome: [ExecutionOutcomeWithId!]!
}

# Query types
type QueryResponseKind {
  blockHeight: BigInt!
  blockHash: String!
}

type AccountView implements QueryResponseKind {
  amount: String!
  locked: String!
  codeHash: String!
  storageUsage: BigInt!
  storagePaidAt: BigInt!
}

# Based on these types from near-api-js:
# export type Finality = 'optimistic' | 'near-final' | 'final'
# export type BlockReference = { blockId: BlockId } | { finality: Finality } | { sync_checkpoint: 'genesis' | 'earliest_available' }
type BlockReference {
  blockId: String
  finality: String
  syncCheckpoint: String
}

type BlockHeader {
  height: BigInt!
  epoch_id: String!
  next_epoch_id: String!
  hash: String!
  prev_hash: String!
  prev_state_root: String!
  chunk_receipts_root: String!
  chunk_headers_root: String!
  chunk_tx_root: String!
  outcome_root: String!
  chunks_included: BigInt!
  challenges_root: String!
  timestamp: BigInt!
  timestamp_nanosec: String!
  random_value: String!
  validator_proposals: [JSON!]!
  chunk_mask: [Boolean!]!
  gas_price: String!
  rent_paid: String!
  validator_reward: String!
  total_supply: String!
  challenges_result: [JSON!]!
  last_final_block: String!
  last_ds_final_block: String!
  next_bp_hash: String!
  block_merkle_root: String!
  approvals: [String!]!
  signature: String!
  latest_protocol_version: BigInt!
}

type Chunk {
  chunk_hash: String!
  prev_block_hash: String!
  outcome_root: String!
  prev_state_root: String!
  encoded_merkle_root: String!
  encoded_length: BigInt!
  height_created: BigInt!
  height_included: BigInt!
  shard_id: BigInt!
  gas_used: BigInt!
  gas_limit: BigInt!
  rent_paid: String!
  validator_reward: String!
  balance_burnt: String!
  outgoing_receipts_root: String!
  tx_root: String!
  validator_proposals: [JSON!]!
  signature: String!
}

type BlockResult {
  author: String!
  header: BlockHeader!
  chunks: [Chunk!]!
}
